import org.scalatest.FunSuite
import org.scalatest.mockito.MockitoSugar

class HistoricTweetSourceSpec extends FunSuite with MockitoSugar {
  test("") {
//    val source = new HistoricTweetSource("some date", "keyword")
//    val twitter = mock[Twitter]
//
//    val searchLimit =
//      new util.HashMap[String, RateLimitStatus]()
//    searchLimit.put("/search/tweets", new RateLimitImpl())
//    when(twitter.getRateLimitStatus("search")).thenReturn(searchLimit)

  }

//  test("Historic Tweet Source gives correct largest id in the tweets returned") {
//    val source = new HistoricTweetSource("some date", "keyword")
//    val status1 = mock[Status]
//    val date = new Date()
//    var i = 0;
//    when(status1.getId).thenReturn(i)
//    when(status1.getCreatedAt).thenReturn(date)
//    when(status1.getText).thenReturn(s"Tweet")
//    when(status1.getFavoriteCount).thenReturn(0)
//
////    val status2 = mock[Status]
////    when(status2.getId).thenReturn(2)
////    when(status1.getCreatedAt).thenReturn(date)
////    when(status1.getText).thenReturn("Tweet 2")
////    when(status1.getFavoriteCount).thenReturn(2)
////
////    val status3 = mock[Status]
////    when(status3.getId).thenReturn(3)
////    when(status1.getCreatedAt).thenReturn(date)
////    when(status1.getText).thenReturn("Tweet 2")
////    when(status1.getFavoriteCount).thenReturn(3)
//
//    val tweetsReturned = List(
//      Tweet(1, date.toString, "Tweet 1", 1),
//      Tweet(2, date.toString, "Tweet 2", 2)
////      Tweet(3, date.toString, "Tweet 3", 3)
//    )
//
//    val lowestIdTweetsTuple =
//      source.processAndGetNextMaxId(List(status1, status1))
//    assert(lowestIdTweetsTuple._1 == 1)
//    assert(lowestIdTweetsTuple._2.size == 3)
//    assert(lowestIdTweetsTuple._2 == tweetsReturned)
//
//  }

}
